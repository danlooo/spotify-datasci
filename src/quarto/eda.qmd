---
title: "Spotify EDA"
format: html
editor: visual
---

```{r setup}

knitr::opts_knit$set(root.dir = here::here())
```

ETL pipeline

```{r}

source("src/targets/init.R")
tar_load(c("terms", "track_audio_features", "track_searches"))

tar_visnetwork()
```

## Summary

Spotify was queried by the following terms. Up to 50 tracks per term were retrieved.

```{r}
terms
```

Features per track

```{r}
tracks <-
  track_audio_features |>
  left_join(track_searches, by = "id") |>
  mutate(term = factor(term))

colnames(tracks)
```

Number of tracks

```{r}
nrow(tracks)
```

Split train/ test data to not bias any analysis. Stratify by term to ensure a balanced data set.

```{r}

tar_load(track_train_test_split)

tracks_train <- tracks |> inner_join(track_train_test_split) |> filter(is_train)
tracks_test <- tracks |> anti_join(tracks_train)
```

## Track features per term

```{r}

features <- c("danceability", "acousticness")

tracks_train |>
  select(term, features) |>
  mutate(across(features, scale)) |>
  pivot_longer(features) |>
  ggplot(aes(term, value)) +
    geom_quasirandom() +
    geom_boxplot(outlier.size = NULL, width = 0.5) +
    facet_wrap(~ name, scales = "free") +
    coord_flip()
```

-   Techno songs are high in danceability and low in acousticness

-   Chill out is a very diverse genre

(Linear Euclidean) ordination biplot to show at all numeric features at once:

```{r}

features <- c("danceability", "energy", "key", "mode", "valence", "loudness", "speechiness", "acousticness", "instrumentalness", "liveness")
  
pca <-
  track_audio_features |>
  semi_join(tracks_train) |>
  column_to_rownames("id") |>
  select(features) |>
  mutate(across(everything(), scale)) |>
  filter(across(everything(), ~ ! is.na(.x))) |>
  prcomp()

tracks_pca <-
    pca$x |>
    as_tibble(rownames = "id") |>
    left_join(track_audio_features, by = "id") |>
    left_join(track_searches, by = "id")

# get medoids
track_clusters <-
  tracks_pca |>
  group_by(term) |>
  summarise(across(c(PC1, PC2), median))

tibble() |>
  ggplot(aes(x = PC1, y = PC2, color = group)) +
  geom_text(
     data = track_clusters |> mutate(group = "term"),
     mapping = aes(label = term)
  ) +
  geom_text(
     data = pca$rotation |> as_tibble(rownames = "feature") |> mutate(group = "feature"),
     mapping = aes(label = feature)
  )
```

More detailed biplot:

```{r}
tibble() |>
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point(
    data = tracks_pca,
    mapping = aes(color = term)
  ) +
  ggrepel::geom_label_repel(
     data = track_clusters,
     mapping = aes(label = term, color = term)
  ) +
  guides(color = FALSE) +
  ggnewscale::new_scale_color() +
  geom_segment(
    data = pca$rotation |> as_tibble(rownames = "feature"),
    mapping = aes(x = 0, y = 0, xend = max(abs(pca$x[,1])) * PC1, yend = max(abs(pca$x[,2])) * PC2),
    arrow = arrow()
  ) +
  ggrepel::geom_label_repel(
    data = pca$rotation |> as_tibble(rownames = "feature"),
    mapping = aes(label = feature, x = max(abs(pca$x[,1])) * PC1, y = max(abs(pca$x[,2])) * PC2)
  )
```

Sanity checks

-   mozart is associated with acousticness

-   ACDC is associated with loudness

## Can we predict the term based on the musical features?

```{r}
summary(pca)$importance["Cumulative Proportion","PC2"]
```

Almost half of the variance can be explained by the first principal components, motivating the prediction of the terms based on the features. These features were also significantly different across the terms:

```{r}
features |>
  paste0(collapse = "+") |>
  paste0("~ term") |>
  lm(data = tracks) |>
  anova()
```

```{python}

import pandas as pd
import numpy as np
from sklearn import linear_model

r.tracks_train
```

Some features are highly correlated, suggesting redundancy, e.g. :

```{r}
tracks |>
  ggplot(aes(danceability, loudness)) +
    geom_point() +
    stat_smooth(method = "lm") +
    stat_cor()
```

Indeed, lots of features were significantly correlated after FDR adjustment:

```{r}

features <- c("danceability", "energy", "key", "mode", "valence", "loudness", "speechiness", "acousticness", "instrumentalness", "liveness")

tracks |>
  select(features) |>
  as.matrix() |>
  Hmisc::rcorr() |>
  broom::tidy() |>
  ungroup() |>
  mutate(q.value = p.value |> p.adjust(method = "fdr")) |>
  filter(q.value < 0.05 & abs(estimate) > 0.2)
```
